#-*- coding:utf-8 -*

from time import sleep
from wx import CallLater
import speech, winUser
import characterProcessing
if not hasattr(characterProcessing, "SYMLVL_SOME"):
	SYMLVL_SOME = characterProcessing.SymbolLevel.SOME
else:
	from characterProcessing import SYMLVL_SOME

from comtypes.gen.ISimpleDOM import ISimpleDOMNode
from NVDAObjects.IAccessible import IAccessible
import controlTypes
if not hasattr(controlTypes, "Role"):
	from controlTypes import ROLE_INTERNALFRAME, ROLE_EDITABLETEXT, ROLE_ALERT, STATE_SELECTED
else:
	ROLE_INTERNALFRAME = controlTypes.Role.INTERNALFRAME
	ROLE_EDITABLETEXT = controlTypes.Role.EDITABLETEXT
	ROLE_ALERT = controlTypes.Role.ALERT
	import controlTypes
if not hasattr(controlTypes, "Role"):
	from controlTypes import ROLE_INTERNALFRAME, ROLE_EDITABLETEXT, ROLE_ALERT, STATE_SELECTED
else:
	ROLE_INTERNALFRAME = controlTypes.Role.INTERNALFRAME
	ROLE_EDITABLETEXT = controlTypes.Role.EDITABLETEXT
	ROLE_ALERT = controlTypes.Role.ALERT
	STATE_SELECTED = controlTypes.State.SELECTED
from scriptHandler import getLastScriptRepeatCount
from ui import message
from tones import beep
import controlTypes
import addonHandler,  os, sys , api
_curAddon=addonHandler.getCodeAddon()
sharedPath=os.path.join(_curAddon.path,"AppModules", "shared")
sys.path.append(sharedPath)
import translation, utis, sharedVars
# import zDevTools as z
del sys.path[-1]
translation.initTranslationWithEnglishFallback()

import re # regex

text = ""
def readContentMail(oDoc, reverse=False, filter = True, title=""): 
	global text

	# return message(title)
	if not oDoc : return # message(u"Veuillez réitérer votre commande de lecture.")
	o= oDoc # .firstChild # du document 
	if title :
		subjLastWord =  title.split(" - Mozilla ")[0]
		subjLastWord =subjLastWord.strip ().split (" ")[-1]
	elif hasattr(oDoc, "name") : 
		subjLastWord =oDoc.name.strip ().split (" ")[-1]
	else :
		subjLastWord =oDoc.IAccessibleObject.accName(0).strip ().split (" ")[-1]
	#message ("avant o.firstChild " + str(o.role) + ", " + str(o.name)) # doit être document
	o=o.firstChild # section ou paragraph
	# message ("après  o.firstChild " + str(o.role)  + ", " + str(o.name))
	if not o : return message(_("error"))
	cCount = oDoc.childCount
	text = title

	if o.next :
		#o=o.next
		i = 1
		if cCount > 100 : message(str(cCount) + " objects. Press Control to stop.")
		#html simple
		while o :
			try : 
				obj = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
				s=obj.innerHTML
				if not s :s=o.name
			except :
				s = "error"
				pass
				
			if s :text+="\n" + s # 2023.07.04 + br added
			if winUser.getKeyState(winUser.VK_CONTROL)&32768:
				beep(100, 30)
				# CallLater(200, message, text)
				CallLater(200, filterSpeakDoc, 		subjLastWord, reverse, filter)
				return

			i += 1
			if cCount > 100 :
				perc = (i / cCount) * 100
				if perc % 10 == 0 :
					if perc == 50.0 : beep(350, 20)
					else : beep(350, 2) # message(str(int(perc)) + "%")
			try : o=o.next
			except : break # fix v 3.4.1
	else: # texte brut
		# beep(500, 30)
		o = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
		#text= unicode (o.innerHTML) if sys.version_info.major == 2 else str (o.innerHTML)
		text += str(o.innerHTML)
	# api.copyToClip (text)
	# message("texte dans le presse-papiers")
	filterSpeakDoc (		subjLastWord, reverse, filter)
	
def shortenUrl(lnk, label) :
	lnk = lnk.replace("https://", label)
	lnk = lnk.replace("http://", label)
	return lnk.split("/")[0]
	
def filterSpeakDoc(endSubj, reverse, filter) :
	global text
	deleteBlocks()
	# text=text.replace ("&nbsp;","").replace("<br>\n", u"àbr") # .replace("&lt;", "<") # .replace ("</span","") # .replace ("&lt;","<").replace ("&gt;",">")
	# reg = re.compile("&(nbsp|lt|gt);") 
	reg = re.compile("&(nbsp);") 
	text=reg.sub("",text)
	reg = re.compile("<(/span|div|/div|b|/b)>") 
	text=reg.sub("",text)
	reg = re.compile("<(div|span) .+?>") 
	text=reg.sub("{",text)
	# api.copyToClip (u"endSubj [" + endSubj + "] text=" + text)
	# beep(200, 40)
	# return

	cleanHeaders()
	cleanLinks()
	# Removes of all remaining HTML tags
	reg= re.compile ("<.+?>")
	text=reg.sub("{",text)
	beep(700, 30)
	api.copyToClip (u"endSubj [" + endSubj + "] text=" + text)
	speech.speakText(text)
	return
	if not filter :
		message(_("Unfiltered reading."))

		# else :
			# text =text.replace (e[0],_(" link %s ") % text_link)

	#remplacement des objets youtube par du texte  (dans le flus rss)
	reg = re.compile ("\<iframe.+?\</iframe\>")
	text =reg.sub (_("youtube object present."), text)
	#suppression du titre dans les flus rss
	reg = re.compile ("\<title\>.+?\</title\>")
	text=reg.sub (" ",text)
	# suppression caractères entre & et point-virgule
	# text=text.replace ("\n"," ").replace ("&nbsp;","").replace ("&lt;","<").replace ("&gt;",">")
	# suppression des < > etc.
	# reg= re.compile ("([\<\> ][\>\< ])+")
	# text =reg.sub (" ",text)
	# suppression  de ?
	# reg = re.compile (" *: *")
	# # text =reg.sub (":",text)
	if not filter :
		text=text.replace (u"àn","\n")
		speech.speak ([text], symbolLevel=SYMLVL_SOME)
		return
	from re import escape

	text =text.replace ("mailto:","")
	# reg = re.compile (_("(\s+|\-{5} ?(E-mail d'origine|Message d'origine|Original Message) ?\-{5})")
	# Translators : remove or translate the french words | is an expression  separator
	pattern = "(\s+|\-{5} ?(" + _("Original Message|E-mail d'origine|Message d'origine") + ") ?\-{5})"
	reg = re.compile(pattern)

	text =reg.sub (" ",text)
	
	# reg = re.compile("((((" + _("From|De|Expéditeur") + "):.+?(" + _("Sujet|Subject|Objet") + "):.+?%s)))") % escape (endSubj)
	# Old pattern 
	# ((((From|De|Expéditeur):.+?(Sujet|Subject|Objet):.+?%s)))
	# New pattern 
	# Translators : remove or translate the french words | is an expression  separator
	pattern = "((((" + _("From|De|Expéditeur") + "):.+?(" + _("Subject|Sujet|Objet") + "):.+?" + endSubj + ")))"
	reg = re.compile(pattern)
	l=reg.findall (text)
	for e in  l:
		e= e[0]
		x=e.split (":")[1]
		arobase =x.find ("@")
		if arobase !=-1:x=x[:arobase]
		x=x.replace ("'","").replace ("\"","")
		if x.count (" "):x=x[:x.rfind (" ")]
		# à vérifier
		text=text.replace (e, "\n. " + _("%s wrote . ") % x)
		text=text.replace (e, "\n. " + _("%s wrote . ") % x)
	#suppression date 
	#pour le confort 
	text =text.replace ("<","")
	#autre champ du style le ... a écrit ...
	s= _(">> > C'aurait été con. >> > >> > J.-F. >> > >> >")
	if text.count (s):text=text[text.find (s)+len (s):]
	# dans un mail daté du 
	# reg = re.compile (("((\s*(Dans un e\-mail daté du|Le) (\d\d[\-/]\d\d[\-/ ]|\d\d .+? )\d{2,4}( (. )?\d\d:\d\d(:\d\d .+?, .+?)?)?,\s*(.+?)a écrit:))"))
	# l=reg.findall (text)
	# for e in l :
		# x=e[7]
		# if x.count ("@"):
			# x=x.split("@")[0]
			# i=x.rfind (" ")
			# if i !=-1:x=x[:i]
			# text=text.replace (e[0], "\n. " + _("%s wrote. ") % x)
		# else:
			# text =text.replace (e[0], "\n. " + _("%s wrote.") % x)
	# text=text.strip ()
	
	#modification de lien  non cliquables
	reg = re.compile ("https?://.+?\s?.+?\s")
	l=reg.findall (text)
	for e in l : 
		text =text.replace (e, shortenUrl(e, " URL "))
	if reverse :
		text=text.split ("\n")
		text.reverse ()
		text =("\n").join (text)
	#vérifie si le texte est vide 
	reg = re.compile ("\S")
	if not reg.search (text):text = _("No text")
	text=text.replace (u"àn","\n")
	message(text)
	# speech.speak  ([text], symbolLevel=SYMLVL_SOME)


def deleteBlocks() :
	global text
	#suppression du pied  de google groupe 
	s = _("You are receiving this message because you are subscribed to the group") #  Google")
	i =text.find (s)
	# api.copyToClip (u"Avant suppr google groups\nposition=" + str(i) + "\n" + text)
	if i !=-1 :text=text[:i]

	#suppression du pied de groups.io
	if text.find("Groups.io Links") > -1 :
		i = text.find("-=-=-")
		if i !=-1 :
			text=text[:i]
		# remplacement temporaire  des \n
	# text=text.replace ("\n",u"àn")
	# suppression style CSS
	if text.find("<style>") > 0 :
		regExp = re.compile ("\<style\>.+?\</style\>")
		text=regExp.sub (" ",text)

def cleanLinks() :
	global text
	# mailto and clickable links replacements
	regExp = re.compile ("(\<a .+?\>(.+?)\</a\>)")
	lbl = _(" link %s ").replace(" %s", "")
	l=regExp.findall (text)
	for e in l :
		text_link = e[1]
		# sharedVars.tlog( "e: " + str(e))
		sharedVars.tlog( "text_link " + str(text_link))
		if "mailto" in e[0]:
			text = text.replace(e[0], text_link + ":")
		elif text_link.startswith ("http") :
			text = text.replace (e[0], shortenUrl(text_link, lbl))

def cleanHeaders() :
	global text
	# Reduction of WinMail and OE headers liene 
	# 1. findAll blocks of headers
	blocks = []
	lbls = _("From|De|Expéditeur")
	p, pEnd = wordsInText(lbls)
	while p > -1 :
		p2, p3 = wordsInText("{|<span>", p) 
# 		p2 = text.find("{", pEnd)
		b = text[p:p2]
		# p2 += len(b)
		sharedVars.tlog("block:" + b)
		blocks.append(b)
		# next block
		p, pEnd = wordsInText(lbls, p3)

	# if len(blocks) == 0 : return
	for e in blocks :
		el = e.replace("<br>", ":")
		sharedVars.tlog("e:" + e)
		t = "--- " + getSenderName(el) +  _("wrote")  + "\n"
		sharedVars.tlog("t:" + t)
		text = text.replace(e, t)
		
	return
		# if utis.wordsMatchWord(search, e[0]) :
			# arr = str(e[0]).split(":")
			# if len(arr) > 2 :
				# repl = "--- " + getSenderName(arr[1]) + " " + _("wrote") + " :\n"
				# sharedVars.tlog( "replacement : " + repl)
def strBetween(t, sep1, sep2) :
	pos1 = t.find(sep1) 
	if pos1 < 0 : return ""
	pos1 +=  len(sep1)
	pos2 = t.find(sep2, pos1)
	if  pos2 < 0 : return ""
	return t[pos1:pos2]

# optimization :the function  strBetween2  acts directly on the text global var
def strBetween2(sep1, sep2) :
	global text
	pos1 = text.find(sep1) 
	if pos1 < 0 : return ""
	pos1 +=  len(sep1)
	pos2 = txt.find(sep2, pos1)
	if  pos2 < 0 : return ""
	return text[pos1:pos2]

def wordsInText(words, start=0) :
	global text
	lWords = words.split("|")
	for e in lWords :
		pos = text.find(e, start)
		if pos > -1 :
			return pos, pos + len(e) + 1
	return pos, pos
	

def getSenderName(header) :
	# On Behalf Of Isabelle Delarue via groups.ioSent 
	if "Behalf Of" in header :
		s = strBetween(header, "Behalf Of", "via groups").strip()  
	elif "</a>" not in header : 
		# e:De : "Viny" &lt;<a href="mailto:vincleg@gmail.com">
		header = header.replace("&lt;", ":")
		s = header.split(":")
		s= s[len(s) - 1]
	else :
		s= strBetween(header, ">", "</a>")
	sharedVars.tlog("retour strBetwwen :" + s)
	return s  
	