#-*- coding:utf-8 -*

from time import sleep
from wx import CallLater
import speech, winUser
import characterProcessing
if not hasattr(characterProcessing, "SYMLVL_SOME"):
	SYMLVL_SOME = characterProcessing.SymbolLevel.SOME
else:
	from characterProcessing import SYMLVL_SOME

from comtypes.gen.ISimpleDOM import ISimpleDOMNode
from NVDAObjects.IAccessible import IAccessible
import controlTypes
if not hasattr(controlTypes, "Role"):
	from controlTypes import ROLE_INTERNALFRAME, ROLE_EDITABLETEXT, ROLE_ALERT, STATE_SELECTED
else:
	ROLE_INTERNALFRAME = controlTypes.Role.INTERNALFRAME
	ROLE_EDITABLETEXT = controlTypes.Role.EDITABLETEXT
	ROLE_ALERT = controlTypes.Role.ALERT
	import controlTypes
if not hasattr(controlTypes, "Role"):
	from controlTypes import ROLE_INTERNALFRAME, ROLE_EDITABLETEXT, ROLE_ALERT, STATE_SELECTED
else:
	ROLE_INTERNALFRAME = controlTypes.Role.INTERNALFRAME
	ROLE_EDITABLETEXT = controlTypes.Role.EDITABLETEXT
	ROLE_ALERT = controlTypes.Role.ALERT
	STATE_SELECTED = controlTypes.State.SELECTED
from scriptHandler import getLastScriptRepeatCount
from ui import message
from tones import beep
import controlTypes
import addonHandler,  os, sys , api
_curAddon=addonHandler.getCodeAddon()
sharedPath=os.path.join(_curAddon.path,"AppModules", "shared")
sys.path.append(sharedPath)
import translation, utis, sharedVars
# import zDevTools as z
del sys.path[-1]
translation.initTranslationWithEnglishFallback()

import re # regex

text = ""
def readContentMail(oDoc, reverse=False, filter = True, title=""): 
	global text

	# return message(title)
	if not oDoc : return # message(u"Veuillez réitérer votre commande de lecture.")
	o= oDoc # .firstChild # du document 
	if title :
		subjLastWord =  title.split(" - Mozilla ")[0]
		subjLastWord =subjLastWord.strip ().split (" ")[-1]
	elif hasattr(oDoc, "name") : 
		subjLastWord =oDoc.name.strip ().split (" ")[-1]
	else :
		subjLastWord =oDoc.IAccessibleObject.accName(0).strip ().split (" ")[-1]
	#message ("avant o.firstChild " + str(o.role) + ", " + str(o.name)) # doit être document
	o=o.firstChild # section ou paragraph
	# message ("après  o.firstChild " + str(o.role)  + ", " + str(o.name))
	if not o : return message(_("error"))
	cCount = oDoc.childCount
	text = title

	if o.next :
		#o=o.next
		i = 1
		if cCount > 100 : message(str(cCount) + " objects. Press Control to stop.")
		#html simple
		while o :
			try : 
				obj = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
				s=obj.innerHTML
				if not s :s=o.name
			except :
				s = "error"
				pass
				
			if s :text+="\n" + s # 2023.07.04 + br added
			if winUser.getKeyState(winUser.VK_CONTROL)&32768:
				beep(100, 30)
				# CallLater(200, message, text)
				CallLater(200, filterSpeakDoc, 		subjLastWord, reverse, filter)
				return

			i += 1
			if cCount > 100 :
				perc = (i / cCount) * 100
				if perc % 10 == 0 :
					if perc == 50.0 : beep(350, 20)
					else : beep(350, 2) # message(str(int(perc)) + "%")
			try : o=o.next
			except : break # fix v 3.4.1
	else: # texte brut
		# beep(500, 30)
		o = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
		#text= unicode (o.innerHTML) if sys.version_info.major == 2 else str (o.innerHTML)
		text += str(o.innerHTML)
	# api.copyToClip (text)
	# message("texte dans le presse-papiers")
	filterSpeakDoc (		subjLastWord, reverse, filter)
	
def shortenUrl(lnk, label) :
	lnk = lnk.replace("https://", label)
	lnk = lnk.replace("http://", label)
	return lnk.split("/")[0]
	
def sayText(freq=440) :
	global text
	beep(freq, 40)
	api.copyToClip(text)
	speech.speakText(text)

		
def filterSpeakDoc(endSubj, reverse, filter) :
	global text
	deleteBlocks()
	# return  sayText(200)
	# text=text.replace ("&nbsp;", " ") # .replace("<br>\n", u"àbr") # .replace("&lt;", "<") # .replace ("</span","") # .replace ("&lt;","<").replace ("&gt;",">")
	text = text.replace("\n", u"àn")
	# return  sayText(200)

	# removes special &char;
	reg = re.compile("(&nbsp;|&gt;)") 
	text=reg.sub(" ",text)

	cleanLinks()
	# Removes of all remaining HTML tags
	reg= re.compile ("<.+?>")
	text=reg.sub("",text)
	cleanStdHeaders()
	cleanMSHeaders(endSubj)
	# removes multiple spaces
	reg = re.compile(" { 2,}")
	text = reg.sub(" ", text)
	if reverse :
		text = text.split("\n")
		text.reverse ()
		text =("\n").join (text)

	# multiple àn
	reg = re.compile(u"(àn){2,}")
	text = reg.sub("\n", text)
	text = text.replace(u"àn", "\n")

	beep(700, 30)
	
	api.copyToClip (u"endSubj [" + endSubj + "] text=\n" + text)
	speech.speakText(text)
	return
	if not filter :
		message(_("Unfiltered reading."))

		# else :
			# text =text.replace (e[0],_(" link %s ") % text_link)

	#remplacement des objets youtube par du texte  (dans le flus rss)
	reg = re.compile ("\<iframe.+?\</iframe\>")
	text =reg.sub (_("youtube object present."), text)
	#suppression du titre dans les flus rss
	reg = re.compile ("\<title\>.+?\</title\>")
	text=reg.sub (" ",text)
	# suppression caractères entre & et point-virgule
	# text=text.replace ("\n"," ").replace ("&nbsp;","").replace ("&lt;","<").replace ("&gt;",">")
	# suppression des < > etc.
	# reg= re.compile ("([\<\> ][\>\< ])+")
	# text =reg.sub (" ",text)
	# suppression  de ?
	# reg = re.compile (" *: *")
	# # text =reg.sub (":",text)
	if not filter :
		text=text.replace (u"àn","\n")
		speech.speak ([text], symbolLevel=SYMLVL_SOME)
		return
	from re import escape

	text =text.replace ("mailto:","")
	# reg = re.compile (_("(\s+|\-{5} ?(E-mail d'origine|Message d'origine|Original Message) ?\-{5})")
	# Translators : remove or translate the french words | is an expression  separator
	pattern = "(\s+|\-{5} ?(" + _("Original Message|E-mail d'origine|Message d'origine") + ") ?\-{5})"
	reg = re.compile(pattern)

	text =reg.sub (" ",text)
	
	# reg = re.compile("((((" + _("From|De|Expéditeur") + "):.+?(" + _("Sujet|Subject|Objet") + "):.+?%s)))") % escape (endSubj)
	# Old pattern 
	# ((((From|De|Expéditeur):.+?(Sujet|Subject|Objet):.+?%s)))
	# New pattern 
	# Translators : remove or translate the french words | is an expression  separator
	pattern = "((((" + _("From|De|Expéditeur") + "):.+?(" + _("Subject|Sujet|Objet") + "):.+?" + endSubj + ")))"
	reg = re.compile(pattern)
	l=reg.findall (text)
	for e in  l:
		e= e[0]
		x=e.split (":")[1]
		arobase =x.find ("@")
		if arobase !=-1:x=x[:arobase]
		x=x.replace ("'","").replace ("\"","")
		if x.count (" "):x=x[:x.rfind (" ")]
		# à vérifier
		text=text.replace (e, "\n. " + _("%s wrote . ") % x)
		text=text.replace (e, "\n. " + _("%s wrote . ") % x)
	#suppression date 
	#pour le confort 
	text =text.replace ("<","")
	#autre champ du style le ... a écrit ...
	s= _(">> > C'aurait été con. >> > >> > J.-F. >> > >> >")
	if text.count (s):text=text[text.find (s)+len (s):]
	# dans un mail daté du 
	# reg = re.compile (("((\s*(Dans un e\-mail daté du|Le) (\d\d[\-/]\d\d[\-/ ]|\d\d .+? )\d{2,4}( (. )?\d\d:\d\d(:\d\d .+?, .+?)?)?,\s*(.+?)a écrit:))"))
	# l=reg.findall (text)
	# for e in l :
		# x=e[7]
		# if x.count ("@"):
			# x=x.split("@")[0]
			# i=x.rfind (" ")
			# if i !=-1:x=x[:i]
			# text=text.replace (e[0], "\n. " + _("%s wrote. ") % x)
		# else:
			# text =text.replace (e[0], "\n. " + _("%s wrote.") % x)
	# text=text.strip ()
	
	#modification de lien  non cliquables
	reg = re.compile ("https?://.+?\s?.+?\s")
	l=reg.findall (text)
	for e in l : 
		text =text.replace (e, shortenUrl(e, " URL "))
	if reverse :
		text=text.split ("\n")
		# veriifie si le texte est vide 
	reg = re.compile ("\S")
	if not reg.search (text):text = _("No text")
	text=text.replace (u"àn","\n")
	message(text)
	# speech.speak  ([text], symbolLevel=SYMLVL_SOME)

def deleteMetas() :
	global text
	lbl = "<meta "
	metas = []
	p, pEnd = findWords(lbl)
	while p > -1 :
		p2 = text.find('">', pEnd) 
		if p2 == -1 : break
		beep(440, 10)
		b = text[p:p2] + '">'
		# sharedVars.tlog("meta:" + b)
		metas.append(b)
		# next block
		p, pEnd = findWords(lbl, p2+2) # +2 is then len of ">
	if len(metas) == 0 : return
	for e in metas :
		# sharedVars.tlog("e:" + e)
		text = text.replace(e, "")

def deleteBlocks() :
	global text
	# Originale message
	s = _("Original Message|E-mail d'origine|Message d'origine")
	reg = re.compile("(\-{5} ?(" + s + ") ?\-{5})")
	text = reg.sub("", text)

		# begin code to debug :  and clean
	# Removes meta tag
	# if text.find("<meta name") > -1 :
		# beep(100, 50)
		# result = re.findall('(startText)(.+)((?:\n.+)+)(endText)',input)
		# reg = re.compile("<meta name.+>")
		# reg = re.compile("(<meta name(.+|\s+))")
		# text = reg.sub("", text)
		# l = reg.findall(text)
		# l = re.findall('(<meta)(.+)((?:\n.+)+)(">)', text)
		# if len(l) > 0 :
			# for e in l :
				# sharedVars.tlog("meta:" + str(e))
	# end code to debug
	deleteMetas()
	#Removes   de google groupe  footer
	s = _("You are receiving this message because you are subscribed to the group") #  Google")
	i =text.find (s)
	# api.copyToClip (u"Avant suppr google groups\nposition=" + str(i) + "\n" + text)
	if i !=-1 :text=text[:i]

	#Removes groups.io footer
	pos, pos2 = findWords("Groups.ioLinks|Groups.io Links")
	if pos > -1 :
		pos = text.find("-=-=")
		if pos != -1 :
			text=text[:pos]
	# suppression style CSS
	if text.find("<style>") > 0 :
		regExp = re.compile ("\<style\>.+?\</style\>")
		text=regExp.sub (" ",text)

def cleanLinks() :
	global text
	# mailto and clickable links replacements
	regExp = re.compile ("(\<a .+?\>(.+?)\</a\>)")
	lbl = _(" link %s ").replace(" %s", "")
	l=regExp.findall (text)
	for e in l :
		text_link = e[1]
		# sharedVars.tlog( "e: " + str(e))
		# sharedVars.tlog( "text_link " + str(text_link))
		if "mailto" in e[0]:
			text = text.replace(e[0], text_link + ":")
		elif text_link.startswith ("http") :
			text = text.replace (e[0], shortenUrl(text_link, lbl))

def cleanStdHeaders() :
	global text
	# Reduction of standard "On date sender wrot :
	# 1. findAll blocks of headers
	blocks = []
	# Translators : do not translate %date_sender%. It will be replaced by a regular expression. Replace french words by your translations.
	lbls = _("On|Le%date_sender%wrote|écrit")
	lbls =  lbls.split("%date_sender%")
	if len(lbls) < 2 : return
	lblOn = lbls[0]
	lblWrote = lbls[1]
	lblWrote = lblWrote.replace("|", " :|") + " :" 
	sharedVars.tlog("lblOn {}, lblWrote {}".format(lblOn, lblWrote))
	
	p, pEnd = findWords(lblOn)
	while p > -1 :
		p2, p3 = findWords(lblWrote, p) 
		if p2 == -1 : 
			beep(440, 10)
			break
		b = text[p:p3] # p3 to include the found lblWrote
		sharedVars.tlog("stdHeader:" + b)
		blocks.append(b)
		# next block
		p, pEnd = findWords(lblOn, p3)

	if len(blocks) == 0 : return
	for e in blocks :
		el = e.split(",")
		if len (el)  < 2 : el = e
		else :
			el = el[1]
		# removes pseudo \n
		el = el.replace(u"àn", " ")
		# removes  multiple spaces
		reg = re.compile(" {2,}")
		el = reg.sub(" ", el)
		sharedVars.tlog("el:" + el)
		text = text.replace(e, "---" + el)
	
def cleanMSHeaders(endSubj) :
	global text
	# Reduction of WinMail and OE headers liene 
	# 1. findAll blocks of headers
	lenSubj = len(endSubj)
	blocks = []
	lbls = _("From|De|Expéditeur") + "|"
	a = lbls.split("|")
	lbls = ""
	for lbl in a :
		if lbl == "" : break
		lbls += lbl + ":|" + lbl + " :|"
	lbls = lbls[:-1]
	# sharedVars.tlog("from labels:" + lbls)

	p, pEnd = findWords(lbls)
	while p > -1 :
		p2 = text.find(endSubj, pEnd) 
		if p2 == -1 : break
		b = text[p:p2] + endSubj
		# sharedVars.tlog("MS header:" + b)
		blocks.append(b)
		# next block
		p, pEnd = findWords(lbls, p2+lenSubj)
	if len(blocks) == 0 : return

	for e in blocks :
		sharedVars.tlog("to replace:" + e)
		# e may contain àn, a pseudo \n 
		t = "\n---" + getSenderName(e) + " " +   _("wrote")+ " : "
		sharedVars.tlog("t:" + t)
		text = text.replace(e, t)
		
	return
		# if utis.wordsMatchWord(search, e[0]) :
			# arr = str(e[0]).split(":")
			# if len(arr) > 2 :
				# repl = "--- " + getSenderName(arr[1]) + " " + _("wrote") + u" :àn"
				# sharedVars.tlog( "replacement : " + repl)
def strBetween(t, sep1, sep2) :
	pos1 = t.find(sep1) 
	if pos1 < 0 : return ""
	pos1 +=  len(sep1)
	pos2 = t.find(sep2, pos1)
	if  pos2 < 0 : return ""
	return t[pos1:pos2]

# optimization :the function  strBetween2  acts directly on the text global var
def strBetween2(sep1, sep2) :
	global text
	pos1 = text.find(sep1) 
	if pos1 < 0 : return ""
	pos1 +=  len(sep1)
	pos2 = txt.find(sep2, pos1)
	if  pos2 < 0 : return ""
	return text[pos1:pos2]

def findWords(words, start=0) :
	global text
	lWords = words.split("|")
	for e in lWords :
		pos = text.find(e, start)
		if pos > -1 :
			return pos, pos + len(e) + 1
	return pos, pos
	

def getSenderName(header) :
	#  header may contain àn
	

	# On Behalf Of Isabelle Delarue via groups.ioSent 
	if "Behalf Of" in header :
		s = strBetween(header, "Behalf Of", "via groups").strip()  
	elif u"àn" in header : 
		s = strBetween(header, ":", u"àn")
	else :
		# s = "à revoir : " + header
		header  = header.split(":") 
		s = (header[1] if len(header) > 1 else header[0])
		if "&lt;" in s :
			s = s.split("&lt;")[0]

	s = s.strip()
	sharedVars.tlog("retour getSenderName :" + s)
	return s
	