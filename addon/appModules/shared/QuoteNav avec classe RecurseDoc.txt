#-*- coding:utf-8 -*
import controlTypes
import translation
translation.initTranslationWithEnglishFallback()

import re, speech, winUser
from tones import beep
from api import  getForegroundObject, copyToClip
from comtypes.gen.ISimpleDOM import ISimpleDOMNode
from NVDAObjects.IAccessible import IAccessible


import sharedVars
import utis 

class RecurseDoc() :
	onLg = "Le"
	wroteLg = "écrit"
	onEn = "On "
	WroteEn = "wrote"
	fromLg = "De"
	fromEn = "From"
	subjLg = "Objet"
	subjEn = "Subject"
	def execute(self, oDoc) :
		# self.doc = oDoc
		self.lines = ""
		self.recurseObjects(oDoc, oDoc.childCount)		

	def recurseObjects (self, oParent, chCount) :
		if  not oParent : 
			self.lines +=  "Null parent object error."
			return False
		try :
			oChild = oParent.firstChild
			if  oChild is None : self.lines.append ("FirstChild error")
		except :
			self.lines+= ", Exception getting  firstChild\n"
			return False
		# maxIdx = chCount - 1
		while oChild :
			role =  oChild.role
			if role == controlTypes.Role.STATICTEXT :
				if hasattr( oChild, "name") :nm = oChild.name
				else: nm = ""
				if not nm : 
					nm = ""
					# 1. StdHeader : On date, Smith wrote :
				if nm == "" :
					nm =""
				elif self.onLg in nm :
					if self.wroteLg in nm : self.lines += "&|"  + nm + "&/|\n"
				elif self.onEn in nm :
					if self.wroteEn in nm : self.lines += "&|"  + nm + "&/|\n" 
				elif nm.startswith(self.fromLg) :
					oChild = self.setSender(oChild, self.subjLg)
				elif nm.startswith(self.fromEn) :
					oChild = self.setSender(oChild, self.subjEn)
				elif "Groups.io Links: You " in nm or "---Infos--" in nm or _("You are receiving this message because you are subscribed to the group") in nm  or "Avast" in nm :
					break
				else : self.lines += nm + "\n"
			elif role == controlTypes.Role.BLOCKQUOTE : 
				self.lines += "&|"
			elif role == controlTypes.Role.LINK : 
				self.lines += " Link " + oChild.name + " "
			elif  role not in (controlTypes.Role.WHITESPACE, controlTypes.Role.SECTION, controlTypes.Role.PARAGRAPH) :
				tLine = ""
				if hasattr(oChild, "role") :
					tLine += str(oChild.role)
				if hasattr(oChild, "name") :
					if oChild.name :
						tLine += ", name : " + str(oChild.name) # 30 first xchars
				if hasattr(oChild, "value") :
					if oChild.value :
						tLine += ", value : " + str(oChild.value)
				self.lines += tLine + "\n"

			cCount  = (int(oChild.childCount) if hasattr(oChild, "childCount") else int(-1))
			if cCount > 0 :
				self.recurseObjects (oChild, cCount)
			oChild = oChild.next
		return True

	def setSender(self, o, subj) :
		orig = o
		i = 1
		while o and i < 4:
			n = o.name
			if n and n.startswith(subj) :
				self.lines += "---" + orig.name # .split(":")[1]  + self.wroteLg + " : \n"
				return o
				i += 1
			o = o.next
		return orig
	

# Attention char Alt+0031 is used as a separator of quotes / messages. Alt+0160. The &nbsp; were removed before.
class QuoteNav() :
	text =  ""
	# the following variables are list indexes
	curItem =  lastItem = curQuote = 0

	def __init__(self) :
		self.lItems  = self.lQuotes = []

		# Translators : do not translate nor remove %date_sender%. Replace french words, word 2 and word 5, by your translations. 
		# The °  char is a temporary replacement of \n
		lbls = _("On|Le%date_sender%wrote|écrit")
		lbls = lbls.split("%date_sender%")
		self.lblOn = lbls[0]
		self.lblWrote = lbls[1]
		sharedVars.tlog("lblON, lblWrote:" + self.lblOn + ", " + self.lblWrote)
		# reg expressions
		self.regBrPLi = re.compile("\n|<br>|<p.+?>|<li.+?>")
		s = "(( |°|\w|\d){1,}(" + lbls[0] + ") .*?(" + lbls[1] + ")(:°| :°|:| :))"
		# s = "(\d{4} .*?(" + lbls[1] + ")(:°| :°|:| :))" 
		# compilation
		self.regStdHdr = re.compile(s)
		# find yea	r  and a space
		# self.regYear =re.compile("20\d\d ")  
		# to removes  multiple spaces
		self.regMultiSpaces = re.compile(" {2,}")
		# to remove multi pseudo new line :  °
		self.regMultiNL = re.compile("°{2,}")
		# to clean sender name
		self.regSender = re.compile("(°|\n|&lt;| via groups\.io)")
		# replace \n that are after a letter or a digit with semicolon
		self.regSemi = re.compile("(\w|\d)\n")
		# v2 issueself.regSender = re.compile("(°|&lt;| via (" + self.lblWrote  + "))")

	def readMail(self, oDoc, rev = False, filter = True): 
		if self.setDoc(oDoc, rev) :
			self.setText(speak=True)
		else : beep(200, 50)

	def setDoc(self, oDoc, nav=False): 
		# rd = RecurseDoc()
		# rd.execute(oDoc)
		# copyToClip(rd.lines)
		# beep(440, 40)
		# return False
		# converts the doc into HTML code
		if not oDoc : return False 
		self.nav = nav
		self.text = "---" # alt+0031
		self.lItems = []
		self.lQuotes = []
		self.lastItem = -1
		self.curItem = 0		
		self.quoteMode = True
		self.subject = "" # mandatory
		parID = str(utis.getIA2Attribute(oDoc.parent))
		if parID == "messageEditor" : 
			fg = getForegroundObject()
			fgID = str(utis.getIA2Attribute(fg))
			if fgID != "spellCheckDlg" :
				sharedVars.curSubject = fg.name
			self.quoteMode = False
		elif parID == "spellCheckDlg" : 
			self.curSubject = parID
			self.QoteMode = False

		sharedVars.curSubject =sharedVars.curSubject.split(" - ")[0].strip()
		if " " in sharedVars.curSubject :
			p = sharedVars. curSubject.split(" ")
			self.subject = p[len(p)-1].strip()
		else :
			self.subject = sharedVars.curSubject

		o=oDoc.firstChild # section ou paragraph
		sharedVars.tlog(u"après  o.firstChild " + str(o.role)  + ", " + str(o.name))
		if not o : 
			speech.speakText(_("error"))
			return False
		cCount = oDoc.childCount
		self.text = "---" 

		if o.next :
			#o=o.next
			i = 1
			if cCount > 75 : speech.speakText(str(cCount) + " objects. Press Control to stop.")
			#html simple
			while o :
				sharedVars.tlog(u"HTML elem:" + str(o.role)  + ", " + str(o.name))
				try : 
					obj = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
					s=obj.innerHTML
					if not s :s=o.name
				except :
					s = "error"
					pass
					
				if s :self.text +="\n" + s # 2023.07.04 + br added
				if winUser.getKeyState(winUser.VK_CONTROL)&32768:
					beep(100, 30)
					return True

				i += 1
				if cCount > 100 :
					perc = (i / cCount) * 100
					if perc % 10 == 0 :
						if perc == 50.0 : beep(350, 20)
						else : beep(350, 2) # message(str(int(perc)) + "%")
				try : o=o.next
				except : break # fix v 3.4.1
		else: # Texte brut
			beep(500, 30)
			o = o.IAccessibleObject.QueryInterface(ISimpleDOMNode)
			sharedVars.tlog("brut:" + str(o))
			self.text += str(o.innerHTML)
		return True

	def getDocObjects(self, oDoc) :
		o = oDoc.firstChild
		while o :
			o = o.next
	

	def setText(self, speak=True) : 
		# self.text = self.htmlCode
		self.deleteBlocks()
		# return  self.speakText(200)
		# replace \n and <br> with °
		self.text = self.regBrPLi.sub("°", self.text)
		# copyToClip(self.text.replace("°", "\n"))
		# return beep(350, 20)
		# removes special &char;
		reg = re.compile("(&nbsp;|&gt;)") 
		self.text=reg.sub(" ",self.text)
		# copyToClip(self.text.replace("°", "\n"))
		# return beep(350, 20)
		self.cleanLinks()
		# Removes of all remaining HTML tags
		reg= re.compile ("<.+?>")
		self.text=reg.sub("",self.text)
		# copyToClip(self.text.replace("°", "\n"))
		# return beep(350, 20)

			# removes multiple spaces 
		# reg = re.compile(" {2,}")
		self.text=self.regMultiSpaces.sub(" ",self.text)
			# removes multiple pseudo \n °
		# reg = re.compile("°{2,}")
		self.text=self.regMultiNL.sub("°",self.text)

		# return  self.speakText(200)
		self.cleanStdHeaders()
		copyToClip(self.text)
		# return beep(200, 40)
		self.cleanMSHeaders()
		copyToClip(self.text)
		# return beep(200, 40)

		# removes multiple  spaces again
		# reg = re.compile(" { 2,}")
		self.text = self.regMultiSpaces.sub(" ", self.text)
		# removes 3 or more  " °" and all &lt;
		reg = re.compile("( °){3,}")
		# self.text = reg.sub("", self.text)

		if not self.nav : # text
			self.text = self.text.replace("°", "\n")
			if speak :
				self.speakText()
		else :
			self.buildLists(speak)

	def buildLists(self, speak) :
		# quotes/messages are separated by alt+0031 char
		if sharedVars.curTab == "main" :
			self.quoteMode = True
			# copyToClip("quoteMode text:\n" + self.text)
			# in order to split the text into quotes
			self.text = self.text.replace("°", " ; ")
			splitSep = "\n"
			self.text = self.regSemi.sub(" ; ", self.text) 
			msg = _("{0} messages in chronological order, ") 
		else :
			self.quoteMode = False 
			# copyToClip("line Mode htmlCode :\n" + self.htmlCode)
			# in order to split the text into lines
			self.text = self.text.replace("°", "\n")
			splitSep = "\n"
			msg = _("{0} messages, {1} lines, ")

		self.curItem = self.lastItem = self.curQuote = 0
		self.lQuotes = []
		# split text into items
		self.lItems = str(self.text).split(splitSep) 
		if not self.lItems :
			self.lItems = []
			beep(200, 20)
			return 
		if self.quoteMode :				
			self.lItems.reverse()
		self.lastItem = len(self.lItems) - 1

		# build quotes indexes list
		self.lQuotes = [idx for (idx, item) in enumerate(self.lItems) if item.startswith("")]
		qCount = len(self.lQuotes)
		msg = msg.format(qCount, self.lastItem + 1)
		# find first non emptuy line 
		while self.lastItem > 0 and self.curItem < 20 :
			# l =  str(self.lItems[self.curItem]).strip()
			# sharedVars.tlog("litem [" + str(self.lItems[self.curItem]) + "]")
			if str(self.lItems[self.curItem]).strip() != "" :
				break
			self.curItem += 1
		if speak :
			speech.speakText(msg + self.lItems[self.curItem])



	def speakText(self, freq=0) :
		if freq > 0 :
			beep(freq, 40)
		# copyToClip(self.text)
		speech.speakText(self.text)

	def deleteMetas(self) :
		lbl = "<meta "
		metas = []
		p, pEnd = self.findWords(lbl)
		while p > -1 :
			p2 = self.text.find('">', pEnd) 
			if p2 == -1 : break
			b = self.text[p:p2] + '">'
			# sharedVars.tlog("meta:" + b)
			metas.append(b)
			# next block
			p, pEnd = self.findWords(lbl, p2+2) # +2 is then len of ">
		if len(metas) == 0 : return
		for e in metas :
			# sharedVars.tlog("e:" + e)
			self.text = self.text.replace(e, "")
			self.text = self.text.replace(e, "")

	def deleteBlocks(self) :
		# Originale message
		s = _("Original Message|E-mail d'origine|Message d'origine")
		reg = re.compile("(\-{5} ?(" + s + ") ?\-{5})")
		self.text = reg.sub("||", self.text)

			# begin code to debug :  and clean
		# Removes meta tag
		# if self.text.find("<meta name") > -1 :
			# beep(100, 50)
			# result = re.findall('(startself.text)(.+)((?:\n.+)+)(endself.text)',input)
			# reg = re.compile("<meta name.+>")
			# reg = re.compile("(<meta name(.+|\s+))")
			# self.text = reg.sub("", self.text)
			# l = reg.findall(self.text)
			# l = re.findall('(<meta)(.+)((?:\n.+)+)(">)', self.text)
			# if len(l) > 0 :
				# for e in l :
					# sharedVars.tlog("meta:" + str(e))
		# end code to debug
		self.deleteMetas()
		#Removes   de google groupe  footer
		s = _("You are receiving this message because you are subscribed to the group") #  Google")
		i =self.text.find (s)
		# copyToClip (u"Avant suppr google groups\nposition=" + str(i) + "\n" + self.text)
		if i !=-1 :self.text=self.text[:i]

		#Removes groups.io footer
		pos, pos2 = self.findWords("Groups.ioLinks|Groups.io Links")
		if pos > -1 :
			pos = self.text.find("-=-=")
			if pos != -1 :
				self.text=self.text[:pos]
		# suppression style CSS
		if self.text.find("<style>") > 0 :
			regExp = re.compile ("\<style\>.+?\</style\>")
			self.text=regExp.sub (" ",self.text)

	def cleanLinks(self) :
		# mailto and clickable links replacements
		regExp = re.compile ("(\<a .+?\>(.+?)\</a\>)")
		lbl = _(" link %s ").replace(" %s", "")
		l=regExp.findall (self.text)
		for e in l :
			self.text_link = e[1]
			# sharedVars.tlog( "e: " + str(e))
			# sharedVars.tlog( "self.text_link " + str(self.text_link))
			if "mailto" in e[0]:
				self.text = self.text.replace(e[0], self.text_link + ":")
			elif self.text_link.startswith ("http") :
				self.text = self.text.replace (e[0], shortenUrl(self.text_link, lbl))

	def cleanStdHeaders(self) :
		# Compress standard "On date sender wrot :
		# 1. findAll blocks of headers
		lo = self.lblOn.split("|")
		lw = self.lblWrote.split("|")

		headers = self.regStdHdr.findall(self.text)
		if len(headers) == 0 : return
		for e in headers :
			h = e[0]
			s = findNearWords(h, lo[0], lw[0], 40)
			if not s :
				s = findNearWords(h, lo[1], lw[1], 40)
			if s : h =   s
			sharedVars.tlog("stdHeader:" +h)
			p = h.split(",")
			if len (p) < 2 : p = h
			else :
				p = p[1]

			# # removes pseudo \n °
			# p = p.replace("°", " ")
			p = self.regMultiSpaces.sub(" ", p)
			p= self.regSender.sub("", p)
			sharedVars.tlog("new h :" + p)
			try :
				self.text = self.text.replace(h, "\n---" + p)
			except :
				beep(100, 30)
				pass
			try :
				print("self.text=" + self.text) 
			except :
				beep(120, 30)
		
	def cleanMSHeaders(self) :
		# Compress  WinMail and OE headers liene 
		# 1. findAll blocks of headers
		# regExpr : De : ° julien ° palibau: ° A : winaide2@googlegroups.com: ° Sent: Monday, July 17, 2023 5:47 AM° Objett: Re: [winaide2] hébergeur de ° fichiers
		lenSubj = len(self.subject)
		blocks = []
		lbls = _("From|De|Expéditeur") + "|"
		a = lbls.split("|")
		lbls = ""
		for lbl in a :
			if lbl == "" : break
			lbls += lbl + ":|" + lbl + " :|"
		lbls = lbls[:-1]
		sharedVars.tlog("from labels:" + lbls)
		regHdr = "((" + lbls + ").+?" + self.subject + ")"
		sharedVars.tlog("regHdr:" + regHdr)
		p, pEnd = self.findWords(lbls)
		while p > -1 :
			p2 = self.text.find(self.subject, pEnd) 
			if p2 == -1 : break
			b = self.text[p:p2] + self.subject
			# sharedVars.tlog("MS header:" + b)
			blocks.append(b)
			# next block
			p, pEnd = self.findWords(lbls, p2+lenSubj)
		if len(blocks) == 0 : return

		for e in blocks :
			sharedVars.tlog("to replace:" + e)
			# e may contain °, a pseudo \n 
			t = "\n---" + getSenderName(e) + " " + _("wrote") + " : "
			sharedVars.tlog("t:" + t)
			self.text = self.text.replace(e, t)
			
		return
			# if utis.wordsMatchWord(search, e[0]) :
				# arr = str(e[0]).split(":")
				# if len(arr) > 2 :
					# repl = "--- " + getSenderName(arr[1]) + " " + _("wrote") + " :°"
					# sharedVars.tlog( "replacement : " + repl)

	def strBetween2(self, sep1, sep2) :
		pos1 = self.text.find(sep1) 
		if pos1 < 0 : return ""
		pos1 +=  len(sep1)
		pos2 = txt.find(sep2, pos1)
		if  pos2 < 0 : return ""
		return self.text[pos1:pos2]

	def findWords(self, words, start=0) :
		lWords = words.split("|")
		for e in lWords :
			pos = self.text.find(e, start)
			if pos > -1 :
				return pos, pos + len(e) + 1
		return pos, pos
		

	def getSenderName(header) :
		#  header may contain °
		

		# On Behalf Of Isabellevia groups.ioSent 
		if "Behalf Of" in header :
			s = strBetween(header, "Behalf Of", "via groups").strip()  
		elif  "via groups.io" in header : 
			# to replace:From: °  Jeremy T. via groups.io: 
			s = strBetween(header, ":", "via")
		else :
			# s = "à revoir : " + header
			header  = header.split(":") 
			s = (header[1] if len(header) > 1 else header[0])
			if "&lt;" in s :
				s = s.split("&lt;")[0]

		
		self.regSender.sub("", s)
		s = s.strip()
		sharedVars.tlog("retour getSenderName :" + s)
		return s
	# methods related to quotes navigation
	def skip(self, n=1) :
		if self.lastItem == -1 : 			self.buildLists(False)
		# skips 1 item before or after
		if n == -1 :
			self.curItem = self.lastItem if self.curItem == 0 else self.curItem - 1
		elif n == 1 :
			self.curItem = 0  if self.curItem == self.lastItem  else self.curItem + 1
		if self.quoteMode :
			speech.speakText(str(self.curItem+1) + ":" + self.lItems[self.curItem])
		else :
			speech.speakText(self.lItems[self.curItem])

	def skipQuote(self, n=1) :
		if self.lastItem == -1 : 			self.buildLists(False)
		# skips 1 quote before or after
		lastQuote = len(self.lQuotes) - 1
		if n == -1 :
			self.curQuote = lastQuote if self.curQuote == 0 else self.curQuote - 1
		elif n == 1 :
			self.curQuote = 0  if self.curQuote == lastQuote  else self.curQuote + 1

		self.curItem = self.lQuotes[self.curQuote]
		# return speech.speakText(" curquote {},  curItem {}".format(self.curQuote, self.curItem))
		speech.speakText(str(self.curQuote+1) + ":" + self.lItems[self.curItem])

	def findItem(self, expr) :
		if self.lastItem == -1 : 			self.buildLists(False)
		lIdx, wIdx = self.indexOf(expr, self.curItem+1)
		if lIdx > -1 :
			self.curItem = lIdx
			speech.speakText(self.lItems[lIdx])
		else :
			beep(120, 20)
	# self.lQuotes = [idx for (idx, item) in enumerate(self.lItems, self.curIndex) if item.find(expr) > -1]
		# try:
			# self.CurItem = self.lItems.index(expr) # ,self.curItem)
			# speech.speakText(self.lItems[self.curItem])
		# except ValueError:
			# beep(100, 20)			
		
			
	def indexOf(self, word, start=0, backward=False) : 
		stopChar = "" # alt+0031
		if not backward :
			step = 1
			# start is the same
			iLast = self.lastItem + 1
		else :
			step = -1
			iLast = 0
		
		for i in range(start, iLast, step) : 
			if stopChar in self.lItems[i] :
				break
			p = self.lItems[i].find(word)
			if p > -1 :
				return i, p
		
		return -1, -1
# normal functions
def getSenderName(header) :
	#  header may contain °
	

	# On Behalf Of Isabelle Delarue via groups.ioSent 
	if "Behalf Of" in header :
		s = strBetween(header, "Behalf Of", "via groups").strip()  
	elif  "via groups.io" in header : 
		# to replace:From: °  Jeremy T. via groups.io: 
		s = strBetween(header, ":", "via")
	else :
		# s = "à revoir : " + header
		header  = header.split(":") 
		s = (header[1] if len(header) > 1 else header[0])
		if "&lt;" in s :
			s = s.split("&lt;")[0]

	s = s.replace("°", " ").strip()
	sharedVars.tlog("retour getSenderName :" + s)
	return s
	
def shortenUrl(lnk, label) :
	lnk = lnk.replace("https://", label)
	lnk = lnk.replace("http://", label)
	return lnk.split("/")[0]
	
def strBetween(t, sep1, sep2) :
	pos1 = t.find(sep1) 
	if pos1 < 0 : return ""
	pos1 +=  len(sep1)
	pos2 = t.find(sep2, pos1)
	if  pos2 < 0 : return ""
	return t[pos1:pos2]

def findNearWords(inStr, w1, w2, max) :
	len1 = len(w1)
	len2 = len(w2)
	p1 = inStr.find(w1) 
	# sharedVars.tlog("premier p1 :" + str(p1))
	while p1 > -1 :
		p2 = inStr.find(w2, p1+len1)
		# sharedVars.tlog("p2 :" + str(p2))
		if p2 == -1 : 
			# sharedVars.tlog(w2 + " not Found")
			break
		if  p2-len2 - p1 + len1  < max :
			# sharedVars.tlog("found")
			return inStr[p1:p2+len2+2]
		p1 = inStr.find(w1, p2) 
		# sharedVars.tlog("p1 :" + str(p1))
	return ""
	
